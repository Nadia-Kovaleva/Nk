function [y, x, h, r] = my(f, I, y0, tol, hmax, h0)
%   h0 = -1 - интегрирование с постоянным шагом hmax,
%         0 - интегрирование с переменным шагом и автоматическим подбором начального шага,
%         h0 - интегрирование с переменным шагом и использованием h0 в качестве начального.

p = 2; % порядок точности

% определение варианта работы
if nargin == 4
    hmax = 0.001;
    h0 = 0;  
elseif nargin == 5
    h0 = 0;    
elseif nargin ~= 6
    error('Некорректные входные аргументы');
end

c2 = 0.4; 
a21 = c2; b1 = 1 - 1/(2*c2); b2 = 1/(2*c2);

K1 = @(x,y) f(x,y);
K2 = @(x,y,h) f(x + c2 * h, y + a21 * h * K1(x,y));
y_my = @(x,y,h) y + h * (b1 * K1(x,y) + b2 * K2(x,y,h));

if h0 == -1 % интегрирование с постоянным шагом
    x = I(1):hmax:I(2);
    N = length(x);
    y = zeros(length(y0),N);
    y(:,1) = y0;
    for i = 2:N
    y(:,i) = y_my(x(i-1),y(:,i-1),hmax);
    end
    h = hmax;
    r = -1;
    
elseif h0 == 0 % интегрирование с переменным шагом
    k = 1;
    x = zeros(1,2); x(k) = I(1);
    y = zeros(length(y0),2); 
    y(:,k) = y0;
    h = zeros(1,2);
    r = zeros(1,2);
    % подбор начального шага
    if max(abs(f(I(1),y0))) < 0.1
        delta_1 = 1/(max(abs(I)))^(p+1) + (norm(f(I(1), y0)))^(p+1);
        h1 = (tol/delta_1)^(1/(p+1));
        delta_2 = 1/(max(abs(I)))^(p+1) + (norm(f(I(1) + h1, y0 + h1*f(I(1),y0))))^(p+1);
        h2 = (tol/delta_2)^(1/(p+1));
        h(k) = min([h1, h2]);
    else
        delta = 1/(max(abs(I)))^(p+1) + (norm(f(I(1), y0)))^(p+1);
        h(k) = (tol/delta)^(1/(p+1));
    end
    % интегрирование
    while x(k) < I(2)
        % находим два приближения
        y1 = y_my(x(k), y(:,k), h(k)); % с шагом h
        y2_ = y_my(x(k), y(:,k), h(k)/2);
        y2 = y_my(x(k) + h(k)/2, y2_, h(k)/2); % после двух шагов h/2
        % оцениваем локальную погрешность 1-го приближения правилом Рунге по норме
        r(k) = (1/(1-2^(-p)))*norm(y2 - y1);
        
        if r(k) > tol*(2^p) % оба приближения не подходят
            h(k) = h(k)/2;
        elseif r(k) > tol % подходит только второе
            x(k + 1) = x(k) + h(k)/2;
            y(:,k + 1) = y2_;
            h(k + 1) = h(k)/2;
            x(k + 2) = x(k) + h(k);
            y(:,k + 2) = y2;
            h(k + 2) = h(k + 1);
            k = k + 2;
        elseif r(k) > tol*(1/2^(p+1)) % подходят оба
            x(k + 1) = x(k) + h(k);
            y(:,k + 1) = y1;
            h(k + 1) = h(k);
            k = k + 1;
        else % даже первое обеспечивает чрезмерную точность
            x(k + 1) = x(k) + h(k);
            y(:,k + 1) = y1;
            h(k + 1) = min([hmax, 2*h(k)]);
            k = k + 1;    
        end
    end
    
else % интегрирование с переменным шагом и начальным шагом h0
    k = 1;
    x = zeros(1,2); x(k) = I(1);
    y = zeros(length(y0),2); y(:,k) = y0;
    h = zeros(1,2); h(k) = min([hmax, h0]);
    r = zeros(1,2);
    % интегрирование 
    while x(k) < I(2)
        % находим два приближения
        y1 = y_my(x(k), y(:,k), h(k)); % с шагом h
        y2_ = y_my(x(k), y(:,k), h(k)/2);
        y2 = y_my(x(k) + h(k)/2, y2_, h(k)/2); % после двух шагов h/2
        % оцениваем локальную погрешность 1-го приближения правилом Рунге по норме
        r(k) = (1/(1-2^(-p)))*norm(y2 - y1);
      
        if r(k) > tol*(2^p) % оба приближения не подходят
            h(k) = h(k)/2;
        elseif r(k) > tol % подходит только второе
            x(k + 1) = x(k) + h(k)/2;
            y(:,k + 1) = y2_;
            h(k + 1) = h(k)/2;
            x(k + 2) = x(k) + h(k);
            y(:,k + 2) = y2;
            h(k + 2) = h(k + 1);
            k = k + 2;
        elseif r(k) > tol*(1/2^(p+1)) % подходят оба
            x(k + 1) = x(k) + h(k);
            y(:,k + 1) = y1;
            h(k + 1) = h(k);
            k = k + 1;
        else % даже первое обеспечивает чрезмерную точность
            x(k + 1) = x(k) + h(k);
            y(:,k + 1) = y1;
            h(k + 1) = min([hmax, 2*h(k)]);
            k = k + 1;    
        end
    end
end
end